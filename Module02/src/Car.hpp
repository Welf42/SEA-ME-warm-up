#ifndef CAR_HPP
#define CAR_HPP

#include <iostream>
#include <memory>
#include <vector>
#include <string>


/*
Learnings: move functions
Move constructor: When a temporary Car object is created or an rvalue reference to a Car object is passed as an argument, the move constructor is called. It takes the Car object as an rvalue reference and transfers the ownership of the car parts to the new Car object using std::move. This avoids unnecessary copying of the car parts.
Move assignment operator: When a Car object is assigned to another Car object using an rvalue reference, the move assignment operator is called. It transfers the ownership of the car parts from the right-hand side Car object to the left-hand side Car object using std::move. This operation is efficient as it avoids copying the car parts.
*/

/*
todo:
create a UML, maybe that helps
*/

class Part {
public:
    virtual void print() const = 0;
    virtual ~Part() = default;
};

class Engine : public Part {
private:
    std::string type;
    int horsepower;
    double displacement;

public:
    Engine(std::string t, int hp, double disp) : type(std::move(t)), horsepower(hp), displacement(disp) {}
    void print() const override {
        std::cout << "Engine: " << type << ", " << horsepower << " HP, " << displacement << "L\n";
    }
};

class Wheel : public Part {
private:
    std::string brand;
    int diameter;

public:
    Wheel(std::string b, int d) : brand(std::move(b)), diameter(d) {}
    void print() const override {
        std::cout << "Wheel: " << brand << ", " << diameter << " inches\n";
    }
};

class Brake : public Part {
private:
    std::string type;
    int diameter;

public:
    Brake(std::string t, int d) : type(std::move(t)), diameter(d) {}
    void print() const override {
        std::cout << "Brake: " << type << ", " << diameter << " mm\n";
    }
};

class Transmission : public Part {
private:
    std::string type;
    int gears;

public:
    Transmission(std::string t, int g) : type(std::move(t)), gears(g) {}
    void print() const override {
        std::cout << "Transmission: " << type << ", " << gears << " speeds\n";
    }
};

class Suspension : public Part {
private:
    std::string type;

public:
    explicit Suspension(std::string t) : type(std::move(t)) {}
    void print() const override {
        std::cout << "Suspension: " << type << "\n";
    }
};

class Body : public Part {
private:
    std::string material;
    double weight;

public:
    Body(std::string m, double w) : material(std::move(m)), weight(w) {}
    void print() const override {
        std::cout << "Body: " << material << ", " << weight << " kg\n";
    }
};

class Car {
private:
    std::string model;
    std::vector<std::unique_ptr<Wheel>> wheels;
    std::vector<std::unique_ptr<Brake>> brakes;
    std::unique_ptr<Engine> engine;
    std::unique_ptr<Transmission> transmission;
    std::unique_ptr<Suspension> suspension;
    std::unique_ptr<Body> body;

public:
    Car(std::string m);
    //The move function, in this context, refers to the move constructor and move assignment operator. These functions are automatically generated by the compiler when using smart pointers like std::unique_ptr.
    void printDetails() const;
    // Destructor: When using smart pointers, the compiler automatically generates a default destructor that properly cleans up the dynamically allocated memory.
};

#endif // CAR_HPP
